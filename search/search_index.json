{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programa DELTA 7o semestre - Algoritmos \u00b6 O principal objetivo da DELTA do 7o semestre \u00e9 promover um espa\u00e7o de pr\u00e1tica para desenho e implementa\u00e7\u00e3o de algoritmos. Em especial, veremos problemas que possam ser resolvidos com vetores e matrizes. A estrutura das aulas ser\u00e1 a seguinte: 30 min - discuss\u00e3o de um problema da aula anterior 70 min - pr\u00e1tica de exerc\u00edcios 20 min - fechamento com d\u00favidas gerais Os temas de cada dia est\u00e3o listados abaixo. No \u00faltimo dia faremos uma nova DELTA retomando atividades feitas durante esta semana. F\u00f3rmulas matem\u00e1ticas Problemas com vetores Matrizes Estruturas de dados simples Exerc\u00edcios livres","title":"Home"},{"location":"#programa-delta-7o-semestre-algoritmos","text":"O principal objetivo da DELTA do 7o semestre \u00e9 promover um espa\u00e7o de pr\u00e1tica para desenho e implementa\u00e7\u00e3o de algoritmos. Em especial, veremos problemas que possam ser resolvidos com vetores e matrizes. A estrutura das aulas ser\u00e1 a seguinte: 30 min - discuss\u00e3o de um problema da aula anterior 70 min - pr\u00e1tica de exerc\u00edcios 20 min - fechamento com d\u00favidas gerais Os temas de cada dia est\u00e3o listados abaixo. No \u00faltimo dia faremos uma nova DELTA retomando atividades feitas durante esta semana. F\u00f3rmulas matem\u00e1ticas Problemas com vetores Matrizes Estruturas de dados simples Exerc\u00edcios livres","title":"Programa DELTA 7o semestre - Algoritmos"},{"location":"01-formulas-matematicas/","text":"F\u00f3rmulas matem\u00e1ticas \u00b6 A implementa\u00e7\u00e3o de programas a partir de f\u00f3rmulas matem\u00e1ticas \u00e9 frequente em SuperComputa\u00e7\u00e3o. Neste primeiro dia iremos melhorar nossas habilidades neste tipo de tarefa. Tarefa 1 \u00b6 O c\u00e1lculo de fun\u00e7\u00f5es trigonom\u00e9tricas como seno e cosseno \u00e9 normalmente feito com as fun\u00e7\u00f5es do cabe\u00e7alho math.h . Nesta tarefa iremos fazer uma implementa\u00e7\u00e3o alternativa para o cosseno , que pode ser calculado pela f\u00f3rmula abaixo. \\cos x = 1 - \\frac{x^2}{2!} + \\frac{x^4}{4!} - \\frac{x^6}{6!} + \\dots \\cos x = 1 - \\frac{x^2}{2!} + \\frac{x^4}{4!} - \\frac{x^6}{6!} + \\dots Seu trabalho ser\u00e1 reimplementar esta fun\u00e7\u00e3o. Note que a s\u00e9rie acima \u00e9 infinita, ent\u00e3o voc\u00ea dever\u00e1 parar de calcular a s\u00e9rie acima quando o m\u00f3dulo do termo atual for menor que 0,001 0,001 . Example Abra o arquivo solucao-t1.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t1 -lsystemd -lm Tarefa 2 \u00b6 (Adaptado de quest\u00e3o de prova) Ao analisar s\u00e9ries temporais de pre\u00e7os de ativos ao longo do tempo uma transforma\u00e7\u00e3o frequentemente aplicada \u00e9 o log da raz\u00e3o entre pre\u00e7os de momentos consecutivos. Ou seja, produzimos uma nova s\u00e9rie seguindo a f\u00f3rmula abaixo: y_0 = x_0 \\\\ y_i = \\log \\frac{x_i}{x_{i-1}} y_0 = x_0 \\\\ y_i = \\log \\frac{x_i}{x_{i-1}} y \u00e9 a s\u00e9rie de sa\u00edda x \u00e9 a s\u00e9rie de entrada Example Abra o arquivo solucao-t2.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t2 -lsystemd Tarefa 3 \u00b6 (Adaptado de quest\u00e3o de prova) A m\u00e9dia m\u00f3vel dos \u00faltimos 7 dias est\u00e1 sendo muito usada na an\u00e1lise de casos de COVID-19 para determinar se uma regi\u00e3o tem tend\u00eancia de subida ou descida. Dada uma s\u00e9rie de n\u00fameros x x , a m\u00e9dia m\u00f3vel dos \u00faltimos D D dias \u00e9 uma nova s\u00e9rie y y que segue a f\u00f3rmula abaixo. y_i = \\frac{1}{D} \\sum_{k=0}^D x_{(i - k)} y_i = \\frac{1}{D} \\sum_{k=0}^D x_{(i - k)} Para os valores de i < 0 i < 0 , considere que x_i = 0 x_i = 0 . Note que tanto x x quanto y y tem a mesma quantidade de dias N N , mas cada elemento de y y \u00e9 uma m\u00e9dia dos D D elementos anteriores de x x . Example Abra o arquivo solucao-t3.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t3 -lsystemd","title":"F\u00f3rmulas matem\u00e1ticas"},{"location":"01-formulas-matematicas/#formulas-matematicas","text":"A implementa\u00e7\u00e3o de programas a partir de f\u00f3rmulas matem\u00e1ticas \u00e9 frequente em SuperComputa\u00e7\u00e3o. Neste primeiro dia iremos melhorar nossas habilidades neste tipo de tarefa.","title":"F\u00f3rmulas matem\u00e1ticas"},{"location":"01-formulas-matematicas/#tarefa-1","text":"O c\u00e1lculo de fun\u00e7\u00f5es trigonom\u00e9tricas como seno e cosseno \u00e9 normalmente feito com as fun\u00e7\u00f5es do cabe\u00e7alho math.h . Nesta tarefa iremos fazer uma implementa\u00e7\u00e3o alternativa para o cosseno , que pode ser calculado pela f\u00f3rmula abaixo. \\cos x = 1 - \\frac{x^2}{2!} + \\frac{x^4}{4!} - \\frac{x^6}{6!} + \\dots \\cos x = 1 - \\frac{x^2}{2!} + \\frac{x^4}{4!} - \\frac{x^6}{6!} + \\dots Seu trabalho ser\u00e1 reimplementar esta fun\u00e7\u00e3o. Note que a s\u00e9rie acima \u00e9 infinita, ent\u00e3o voc\u00ea dever\u00e1 parar de calcular a s\u00e9rie acima quando o m\u00f3dulo do termo atual for menor que 0,001 0,001 . Example Abra o arquivo solucao-t1.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t1 -lsystemd -lm","title":"Tarefa 1"},{"location":"01-formulas-matematicas/#tarefa-2","text":"(Adaptado de quest\u00e3o de prova) Ao analisar s\u00e9ries temporais de pre\u00e7os de ativos ao longo do tempo uma transforma\u00e7\u00e3o frequentemente aplicada \u00e9 o log da raz\u00e3o entre pre\u00e7os de momentos consecutivos. Ou seja, produzimos uma nova s\u00e9rie seguindo a f\u00f3rmula abaixo: y_0 = x_0 \\\\ y_i = \\log \\frac{x_i}{x_{i-1}} y_0 = x_0 \\\\ y_i = \\log \\frac{x_i}{x_{i-1}} y \u00e9 a s\u00e9rie de sa\u00edda x \u00e9 a s\u00e9rie de entrada Example Abra o arquivo solucao-t2.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t2 -lsystemd","title":"Tarefa 2"},{"location":"01-formulas-matematicas/#tarefa-3","text":"(Adaptado de quest\u00e3o de prova) A m\u00e9dia m\u00f3vel dos \u00faltimos 7 dias est\u00e1 sendo muito usada na an\u00e1lise de casos de COVID-19 para determinar se uma regi\u00e3o tem tend\u00eancia de subida ou descida. Dada uma s\u00e9rie de n\u00fameros x x , a m\u00e9dia m\u00f3vel dos \u00faltimos D D dias \u00e9 uma nova s\u00e9rie y y que segue a f\u00f3rmula abaixo. y_i = \\frac{1}{D} \\sum_{k=0}^D x_{(i - k)} y_i = \\frac{1}{D} \\sum_{k=0}^D x_{(i - k)} Para os valores de i < 0 i < 0 , considere que x_i = 0 x_i = 0 . Note que tanto x x quanto y y tem a mesma quantidade de dias N N , mas cada elemento de y y \u00e9 uma m\u00e9dia dos D D elementos anteriores de x x . Example Abra o arquivo solucao-t3.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t3 -lsystemd","title":"Tarefa 3"},{"location":"02-problemas-com-vetores/","text":"Itera\u00e7\u00e3o em vetores \u00b6 Neste segundo dia iremos trabalhar com problemas com itera\u00e7\u00e3o em vetores. Tarefa 1 \u00b6 Raul gosta muito de Kare e conhece uma s\u00e9rie de mercados orientais que vendem este prato. Por\u00e9m, cada mercado vende por\u00e7\u00f5es de tamanhos diferentes e o Raul, p\u00e3o duro que \u00e9, quer saber qual \u00e9 o local que vende o Kare mais barato. Seu trabalho ser\u00e1 criar uma fun\u00e7\u00e3o que encontra a oferta mais barata dado um vetor de produtos contendo um campo pre\u00e7o e um campo peso. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t1 -lsystemd -lm Tarefa 2 \u00b6 Dada uma sequ\u00eancia de n\u00fameros, encontre o par que possui a maior soma. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t2 -lsystemd -lm Com os testes passando, reflita sobre a quest\u00e3o abaixo. Question Qual a complexidade computacional da sua solu\u00e7\u00e3o? \u00c9 poss\u00edvel fazer melhor? Tarefa 3 \u00b6 Dada uma sequ\u00eancia de n\u00fameros inteiros, mostrar no terminal a contagem de quantas vezes cada um aparece. Veja o exemplo abaixo. Entrada 1 3 0 1 5 7 0 1 3 Sa\u00edda 1 aparece 3 vezes 3 aparece 2 vezes 0 aparece 2 vezes 5 aparece 1 vez 7 aparece 1 vez Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t3 -lsystemd -lm","title":"Itera\u00e7\u00e3o em vetores"},{"location":"02-problemas-com-vetores/#iteracao-em-vetores","text":"Neste segundo dia iremos trabalhar com problemas com itera\u00e7\u00e3o em vetores.","title":"Itera\u00e7\u00e3o em vetores"},{"location":"02-problemas-com-vetores/#tarefa-1","text":"Raul gosta muito de Kare e conhece uma s\u00e9rie de mercados orientais que vendem este prato. Por\u00e9m, cada mercado vende por\u00e7\u00f5es de tamanhos diferentes e o Raul, p\u00e3o duro que \u00e9, quer saber qual \u00e9 o local que vende o Kare mais barato. Seu trabalho ser\u00e1 criar uma fun\u00e7\u00e3o que encontra a oferta mais barata dado um vetor de produtos contendo um campo pre\u00e7o e um campo peso. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t1 -lsystemd -lm","title":"Tarefa 1"},{"location":"02-problemas-com-vetores/#tarefa-2","text":"Dada uma sequ\u00eancia de n\u00fameros, encontre o par que possui a maior soma. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t2 -lsystemd -lm Com os testes passando, reflita sobre a quest\u00e3o abaixo. Question Qual a complexidade computacional da sua solu\u00e7\u00e3o? \u00c9 poss\u00edvel fazer melhor?","title":"Tarefa 2"},{"location":"02-problemas-com-vetores/#tarefa-3","text":"Dada uma sequ\u00eancia de n\u00fameros inteiros, mostrar no terminal a contagem de quantas vezes cada um aparece. Veja o exemplo abaixo. Entrada 1 3 0 1 5 7 0 1 3 Sa\u00edda 1 aparece 3 vezes 3 aparece 2 vezes 0 aparece 2 vezes 5 aparece 1 vez 7 aparece 1 vez Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t3 -lsystemd -lm","title":"Tarefa 3"},{"location":"03-matrizes/","text":"Matrizes em C \u00b6 Em C precisamos nos preocupar com o layout de mem\u00f3ria dos dados que armazenamos. No caso de matrizes, a maneira mais eficiente de faz\u00ea-lo \u00e9 guard\u00e1-las de maneira linear . Colocaremos na mem\u00f3ria uma linha depois da outra, como na figura abaixo. Question Em uma matriz de tamanho 4x7 (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o 2x5 (linha 3, coluna 6)? Considere que come\u00e7amos a contar linhas e colunas do zero. Details Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 19 . Este n\u00famero \u00e9 obtido pela express\u00e3o i * c + j i \u00e9 a linha a ser acessada j \u00e9 a coluna c \u00e9 o n\u00famero de colunas da matriz 19 = 2 * 7 + 5 Um pouco de contexto: transporte coletivo \u00b6 O transporte coletivo pode ser organizado em grandes terminais que ligam diferentes regi\u00f5es da cidade. Podemos representar as liga\u00e7\u00f5es entre terminais usando uma matriz em que a posi\u00e7\u00e3o i,j representa o n\u00famero de \u00f4nibus que saem do terminal i e chegam no terminal j . Naturalmente as posi\u00e7\u00f5es i,j e j,i tem o mesmo valor, pois os \u00f4nibus sempre saem de um terminal e retornam no mesmo dia. Tarefa 1 \u00b6 Para cada terminal de \u00f4nibus, gostar\u00edamos de descobrir o terminal destino que recebe menor quantidade de \u00f4nibus. Se um terminal n\u00e3o receber nenhum \u00f4nibus ele deve ser ignorado. Veja os exemplos abaixo. Tanto a matriz de entrada como o vetor de sa\u00edda ser\u00e3o recebidos como argumentos. Entrada 0 4 5 7 0 4 0 2 0 1 5 2 0 9 3 7 0 9 0 3 0 1 3 3 0 Sa\u00edda 4 1 2 3 1 Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes -lsystemd -lm Tarefa 2 \u00b6 Tamb\u00e9m \u00e9 importante identificar o quanto cada terminal est\u00e1 conectado com outros. Nesta tarefa voc\u00ea dever\u00e1 encontrar o terminal que recebe a maior quantidade de \u00f4nibus o terminal que est\u00e1 conectado com a maior quantidade de outros terminais. Entrada 0 4 5 0 1 4 0 0 0 1 5 0 0 9 3 0 0 9 0 3 1 1 3 3 0 Sa\u00edda O terminal 2 \u00e9 o que recebe mais onibus (17 onibus) O terminal 4 \u00e9 o mais conectado (4 terminais) Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes -lsystemd -lm Tarefa 3 (desafio) \u00b6 Uma grande preocupa\u00e7\u00e3o no transporte \u00e9 que seja poss\u00edvel atravessar a cidade usando os \u00f4nibus disponibilizados. Gostar\u00edamos de responder \u00e0 pergunta: \"\u00e9 poss\u00edvel, partindo do terminal s , chegar ao terminal d ?\" Estamos interessados em uma resposta Sim/N\u00e3o e n\u00e3o necessariamente na resposta que utiliza o menor n\u00famero de \u00f4nibus. Veja os exemplos abaixo. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t1 -lsystemd -lm Desenhe os exemplos no papel. Ser\u00e1 mais f\u00e1cil de entender as respostas. Exemplo 1 \u00b6 Entrada 0 2 3 0 0 2 0 1 0 0 3 1 0 0 0 0 0 0 0 5 0 0 0 5 0 No exemplo acima \u00e9 imposs\u00edvel chegar do terminal 1 ao terminal 3 . Exemplo 2 \u00b6 Entrada 0 5 0 5 0 2 0 2 0 No exemplo acima \u00e9 poss\u00edvel chegar do terminal 1 at\u00e9 o terminal 3 passando pelo terminal 2 .","title":"Matrizes em *C*"},{"location":"03-matrizes/#matrizes-em-c","text":"Em C precisamos nos preocupar com o layout de mem\u00f3ria dos dados que armazenamos. No caso de matrizes, a maneira mais eficiente de faz\u00ea-lo \u00e9 guard\u00e1-las de maneira linear . Colocaremos na mem\u00f3ria uma linha depois da outra, como na figura abaixo. Question Em uma matriz de tamanho 4x7 (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o 2x5 (linha 3, coluna 6)? Considere que come\u00e7amos a contar linhas e colunas do zero. Details Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 19 . Este n\u00famero \u00e9 obtido pela express\u00e3o i * c + j i \u00e9 a linha a ser acessada j \u00e9 a coluna c \u00e9 o n\u00famero de colunas da matriz 19 = 2 * 7 + 5","title":"Matrizes em C"},{"location":"03-matrizes/#um-pouco-de-contexto-transporte-coletivo","text":"O transporte coletivo pode ser organizado em grandes terminais que ligam diferentes regi\u00f5es da cidade. Podemos representar as liga\u00e7\u00f5es entre terminais usando uma matriz em que a posi\u00e7\u00e3o i,j representa o n\u00famero de \u00f4nibus que saem do terminal i e chegam no terminal j . Naturalmente as posi\u00e7\u00f5es i,j e j,i tem o mesmo valor, pois os \u00f4nibus sempre saem de um terminal e retornam no mesmo dia.","title":"Um pouco de contexto: transporte coletivo"},{"location":"03-matrizes/#tarefa-1","text":"Para cada terminal de \u00f4nibus, gostar\u00edamos de descobrir o terminal destino que recebe menor quantidade de \u00f4nibus. Se um terminal n\u00e3o receber nenhum \u00f4nibus ele deve ser ignorado. Veja os exemplos abaixo. Tanto a matriz de entrada como o vetor de sa\u00edda ser\u00e3o recebidos como argumentos. Entrada 0 4 5 7 0 4 0 2 0 1 5 2 0 9 3 7 0 9 0 3 0 1 3 3 0 Sa\u00edda 4 1 2 3 1 Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes -lsystemd -lm","title":"Tarefa 1"},{"location":"03-matrizes/#tarefa-2","text":"Tamb\u00e9m \u00e9 importante identificar o quanto cada terminal est\u00e1 conectado com outros. Nesta tarefa voc\u00ea dever\u00e1 encontrar o terminal que recebe a maior quantidade de \u00f4nibus o terminal que est\u00e1 conectado com a maior quantidade de outros terminais. Entrada 0 4 5 0 1 4 0 0 0 1 5 0 0 9 3 0 0 9 0 3 1 1 3 3 0 Sa\u00edda O terminal 2 \u00e9 o que recebe mais onibus (17 onibus) O terminal 4 \u00e9 o mais conectado (4 terminais) Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes -lsystemd -lm","title":"Tarefa 2"},{"location":"03-matrizes/#tarefa-3-desafio","text":"Uma grande preocupa\u00e7\u00e3o no transporte \u00e9 que seja poss\u00edvel atravessar a cidade usando os \u00f4nibus disponibilizados. Gostar\u00edamos de responder \u00e0 pergunta: \"\u00e9 poss\u00edvel, partindo do terminal s , chegar ao terminal d ?\" Estamos interessados em uma resposta Sim/N\u00e3o e n\u00e3o necessariamente na resposta que utiliza o menor n\u00famero de \u00f4nibus. Veja os exemplos abaixo. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes-t1 -lsystemd -lm Desenhe os exemplos no papel. Ser\u00e1 mais f\u00e1cil de entender as respostas.","title":"Tarefa 3 (desafio)"},{"location":"03-matrizes/#exemplo-1","text":"Entrada 0 2 3 0 0 2 0 1 0 0 3 1 0 0 0 0 0 0 0 5 0 0 0 5 0 No exemplo acima \u00e9 imposs\u00edvel chegar do terminal 1 ao terminal 3 .","title":"Exemplo 1"},{"location":"03-matrizes/#exemplo-2","text":"Entrada 0 5 0 5 0 2 0 2 0 No exemplo acima \u00e9 poss\u00edvel chegar do terminal 1 at\u00e9 o terminal 3 passando pelo terminal 2 .","title":"Exemplo 2"},{"location":"04-diversos/","text":"Exerc\u00edcios diversos \u00b6 No dia de hoje n\u00e3o trabalharemos com nenhum conceito em espec\u00edfico, mas usaremos Tarefa 1 \u00b6 J\u00e1 vimos que em C os tipos inteiros tem tamanhos fixos e que muitas vezes precisamos ficar atentos com os limites dos tipos usados. Diversas linguagens oferecem um tipo adicionar chamado BigInt que faz contas com precis\u00e3o arbitr\u00e1ria. Para isso eles guardam os d\u00edgitos (em base 10) de um n\u00famero em um vetor e implementam manualmente opera\u00e7\u00f5es aritm\u00e9ticas. Example Sua tarefa ser\u00e1 implementar a soma de dois BigInt . Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall testes.c -o testes -lsystemd -lm Tarefa 2 \u00b6 No diagn\u00f3stico da delta fizemos um exerc\u00edcio de identificar se os par\u00eanteses de uma string est\u00e3o equilibrados. Vamos agora dar um passo al\u00e9m: queremos equilibrar a quantidade de \"()\", \"[]\" e \"{}\" em uma string. Ou seja, a string \"([)]\" n\u00e3o \u00e9 v\u00e1lida pois o primeiro \"(\" \u00e9 fechado antes do fechamento do \"[\" que vem em seguida. Para a string estar equilibrada \u00e9 necess\u00e1rio que todos os tr\u00eas tipos de par\u00eanteses sejam fechados na ordem em que foram abertos. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes -lsystemd -lm Tarefa 3 \u00b6 Dadas N N tarefas, dizemos que uma tarefa i depende de uma tarefa j se precisamos executar i antes de j . Essa rela\u00e7\u00e3o de depend\u00eancia pode ser codificada em uma matriz, em que o elemento i,j vale 1 se i depende de j e 0 caso contr\u00e1rio. Question A matriz acima \u00e9 sim\u00e9trica? Ou seja, o valor de i,j \u00e9 sempre igual ao valor de j,i ? Desejamos identificar situa\u00e7\u00f5es de depend\u00eancia circular . Isto ocorre quando uma tarefa i depende de outras tarefas que eventualmente dependem de i tamb\u00e9m. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes -lsystemd -lm Veja os exemplos abaixo. Para facilitar sua compreens\u00e3o, desenhe as rela\u00e7\u00f5es de depend\u00eancia representadas pelas matrizes mostradas. Exemplo 1 \u00b6 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 Neste caso n\u00e3o h\u00e1 depend\u00eancia circular. Exemplo 2 \u00b6 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 Neste caso h\u00e1 depend\u00eancia circular. Exemplo 3 \u00b6 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 Neste caso n\u00e3o h\u00e1 depend\u00eancia circular. Exemplo 4 \u00b6 0 1 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 Neste caso h\u00e1 depend\u00eancia circular: 0 -> 1 -> 4 -> 5 -> 0 . Exemplo 5 \u00b6 0 1 1 0 Neste caso h\u00e1 depend\u00eancia circular.","title":"Exerc\u00edcios diversos"},{"location":"04-diversos/#exercicios-diversos","text":"No dia de hoje n\u00e3o trabalharemos com nenhum conceito em espec\u00edfico, mas usaremos","title":"Exerc\u00edcios diversos"},{"location":"04-diversos/#tarefa-1","text":"J\u00e1 vimos que em C os tipos inteiros tem tamanhos fixos e que muitas vezes precisamos ficar atentos com os limites dos tipos usados. Diversas linguagens oferecem um tipo adicionar chamado BigInt que faz contas com precis\u00e3o arbitr\u00e1ria. Para isso eles guardam os d\u00edgitos (em base 10) de um n\u00famero em um vetor e implementam manualmente opera\u00e7\u00f5es aritm\u00e9ticas. Example Sua tarefa ser\u00e1 implementar a soma de dois BigInt . Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall testes.c -o testes -lsystemd -lm","title":"Tarefa 1"},{"location":"04-diversos/#tarefa-2","text":"No diagn\u00f3stico da delta fizemos um exerc\u00edcio de identificar se os par\u00eanteses de uma string est\u00e3o equilibrados. Vamos agora dar um passo al\u00e9m: queremos equilibrar a quantidade de \"()\", \"[]\" e \"{}\" em uma string. Ou seja, a string \"([)]\" n\u00e3o \u00e9 v\u00e1lida pois o primeiro \"(\" \u00e9 fechado antes do fechamento do \"[\" que vem em seguida. Para a string estar equilibrada \u00e9 necess\u00e1rio que todos os tr\u00eas tipos de par\u00eanteses sejam fechados na ordem em que foram abertos. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes -lsystemd -lm","title":"Tarefa 2"},{"location":"04-diversos/#tarefa-3","text":"Dadas N N tarefas, dizemos que uma tarefa i depende de uma tarefa j se precisamos executar i antes de j . Essa rela\u00e7\u00e3o de depend\u00eancia pode ser codificada em uma matriz, em que o elemento i,j vale 1 se i depende de j e 0 caso contr\u00e1rio. Question A matriz acima \u00e9 sim\u00e9trica? Ou seja, o valor de i,j \u00e9 sempre igual ao valor de j,i ? Desejamos identificar situa\u00e7\u00f5es de depend\u00eancia circular . Isto ocorre quando uma tarefa i depende de outras tarefas que eventualmente dependem de i tamb\u00e9m. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall solucao.c testes.c -o testes -lsystemd -lm Veja os exemplos abaixo. Para facilitar sua compreens\u00e3o, desenhe as rela\u00e7\u00f5es de depend\u00eancia representadas pelas matrizes mostradas.","title":"Tarefa 3"},{"location":"04-diversos/#exemplo-1","text":"0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 Neste caso n\u00e3o h\u00e1 depend\u00eancia circular.","title":"Exemplo 1"},{"location":"04-diversos/#exemplo-2","text":"0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 Neste caso h\u00e1 depend\u00eancia circular.","title":"Exemplo 2"},{"location":"04-diversos/#exemplo-3","text":"0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 Neste caso n\u00e3o h\u00e1 depend\u00eancia circular.","title":"Exemplo 3"},{"location":"04-diversos/#exemplo-4","text":"0 1 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 Neste caso h\u00e1 depend\u00eancia circular: 0 -> 1 -> 4 -> 5 -> 0 .","title":"Exemplo 4"},{"location":"04-diversos/#exemplo-5","text":"0 1 1 0 Neste caso h\u00e1 depend\u00eancia circular.","title":"Exemplo 5"},{"location":"05-diversos/","text":"Exerc\u00edcios diversos \u00b6 Os exerc\u00edcios finais n\u00e3o tem nenhum tema em particular e visam servir de pr\u00e1tica para o desenho de algoritmo simples. Idealmente ambos deveriam ser finalizados em menos de 60 minutos. Tarefa 1 \u00b6 Dadas duas strings, verifique se uma \u00e9 anagrama da outra. Veja testes.c para diversos exemplos de anagramas. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall testes.c -o testes -lsystemd -lm Tarefa 2 \u00b6 Dados dois vetores de inteiros, preencha um terceiro vetor com a interese\u00e7\u00e3o dos dois primeiros. Voc\u00ea pode supor que os vetores n\u00e3o possuem elementos repetidos, mas n\u00e3o pode supor que eles est\u00e3o ordenados. Voc\u00ea pode supor que a vari\u00e1vel de sa\u00edda j\u00e1 est\u00e1 alocada e cont\u00e9m espa\u00e7o suficiente para guardar todos os elementos necess\u00e1rios. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall testes.c -o testes -lsystemd -lm","title":"Exerc\u00edcios diversos"},{"location":"05-diversos/#exercicios-diversos","text":"Os exerc\u00edcios finais n\u00e3o tem nenhum tema em particular e visam servir de pr\u00e1tica para o desenho de algoritmo simples. Idealmente ambos deveriam ser finalizados em menos de 60 minutos.","title":"Exerc\u00edcios diversos"},{"location":"05-diversos/#tarefa-1","text":"Dadas duas strings, verifique se uma \u00e9 anagrama da outra. Veja testes.c para diversos exemplos de anagramas. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall testes.c -o testes -lsystemd -lm","title":"Tarefa 1"},{"location":"05-diversos/#tarefa-2","text":"Dados dois vetores de inteiros, preencha um terceiro vetor com a interese\u00e7\u00e3o dos dois primeiros. Voc\u00ea pode supor que os vetores n\u00e3o possuem elementos repetidos, mas n\u00e3o pode supor que eles est\u00e3o ordenados. Voc\u00ea pode supor que a vari\u00e1vel de sa\u00edda j\u00e1 est\u00e1 alocada e cont\u00e9m espa\u00e7o suficiente para guardar todos os elementos necess\u00e1rios. Example Abra o arquivo solucao.c e modifique-o para passar nos testes. Para isto basta compilar o programa com as instru\u00e7\u00f5es abaixo e execut\u00e1-lo. gcc -Og -Wall testes.c -o testes -lsystemd -lm","title":"Tarefa 2"},{"location":"prova/","text":"Prova DELTA de algoritmos \u00b6 Esta prova cont\u00e9m tr\u00eas quest\u00f5es e tem tempo total de dura\u00e7\u00e3o de 90 minutos . As regras da prova s\u00e3o simples: A prova \u00e9 individual. \u00c9 permitido consultar qualquer material na internet. N\u00e3o \u00e9 permitido consultar outras pessoas. N\u00e3o \u00e9 permitido copiar grandes trechos e/ou solu\u00e7\u00f5es prontas. Sempre que usar uma fonte externa, adicione uma refer\u00eancia no seu c\u00f3digo usando um coment\u00e1rio. Todas as quest\u00f5es de implementa\u00e7\u00e3o tem testes automatizados. A quantidade de testes que passam \u00e9 mostrada ao executar o testador. As quest\u00f5es avaliam a capacidade de desenhar uma solu\u00e7\u00e3o para os problemas apresentados e estrutur\u00e1-la usando uma linguagem de programa\u00e7\u00e3o. Todas as quest\u00f5es podem ser resolvidas usando conhecimentos b\u00e1sicos de Linguagem C . Em todas as quest\u00f5es voc\u00ea dever\u00e1 implementar somente a fun\u00e7\u00e3o pedida. Um arquivo .o com uma fun\u00e7\u00e3o main contendo testes automatizados \u00e9 fornecido para cada quest\u00e3o. Para testar basta executar o execut\u00e1vel criado. Importante Um aluno estar\u00e1 minimamente capacitado se acertar TODAS as quest\u00f5es no tempo da prova. Para fazer a prova voc\u00ea precisar\u00e1 dos pacotes build-essential libsystemd-dev instalados em seu sistema. Essa prova possui um sistema de telemetria que registra quando um aluno tenta fazer uma quest\u00e3o. Toda informa\u00e7\u00e3o \u00e9 coletada anonimamente e \u00e9 imposs\u00edvel associar uma tentativa de resolu\u00e7\u00e3o a um aluno em espec\u00edfico. Toda a informa\u00e7\u00e3o coletada ser\u00e1 usada para melhorar o curso de Engenharia da Computa\u00e7\u00e3o. Nenhuma informa\u00e7\u00e3o \u00e9 usada para nota . Quest\u00e3o 1 \u00b6 Seu trabalho ser\u00e1 criar uma fun\u00e7\u00e3o que identifica o tamanho da maior sequ\u00eancia estritamente crescente em um vetor. Uma sequ\u00eancia de n\u00fameros a_i, .... a_k a_i, .... a_k \u00e9 crescente se a_j < a_{j+1} a_j < a_{j+1} para todo j=i ... k-1 . Coloque sua resposta no arquivo questao1/solucao.c . Sua fun\u00e7\u00e3o dever\u00e1 ter assinatura int maior_sequencia_crescente(int *vetor, int n) . Para compilar seu programa use gcc -Wall -Og solucao.c testes.o -o testes-q1 -lsystemd Exemplos \u00b6 O tamanho da maior sequ\u00eancia crescente de 3 2 1 3 5 7 9 8 \u00e9 5: ela come\u00e7a no 1 e vai at\u00e9 o 9 . O tamanho da maior sequ\u00eancia crescente de 5 6 4 7 3 8 \u00e9 2 e existe empate entre 5 6 , 4 7 e 3 8 . Quest\u00e3o 2 \u00b6 Balancear par\u00eanteses \u00e9 uma tarefa comum ao intepretar textos estruturados. Fa\u00e7a uma fun\u00e7\u00e3o int parenteses_balanceados(char *texto) que retorna 1 se os par\u00eanteses de um texto est\u00e3o balanceados e 0 caso contr\u00e1rio. Coloque sua resposta em questao2/solucao.c . Para compilar seu programa use gcc -Wall -Og solucao.c testes.o -o testes-q2 -lsystemd Quest\u00e3o 3 \u00b6 Voc\u00ea foi contratado para criar uma m\u00e1quina de caf\u00e9 que recebe pagamentos em dinheiro. Um dos pontos importantes \u00e9 devolver a quantidade correta de trocos usando moedas de 50, 25, 10, 5 e 1 centavos. Voc\u00ea dever\u00e1 fazer uma fun\u00e7\u00e3o void troco_moedas(int reais, int centavos, int *q50, int *q25, int *q10, int *q5, int *q1) que, dada a quantidade de reais e centavos a serem dados de troco retorne a quantidade de moedas de cada tipo a serem usadas. Voc\u00ea dever\u00e1 usar a menor quantidade de moedas poss\u00edvel. Voc\u00ea pode supor que tem infinitas moedas a sua disposi\u00e7\u00e3o. Coloque sua resposta em questao3/solucao.c . Para compilar seu programa use gcc -Wall -Og solucao.c testes.o -o testes-q3 -lsystemd Exemplos \u00b6 Para devolver 35 centavos de troco retornamos uma moeda de 25 e uma moeda de 10. Note que retornar 3 moedas de 10 e uma de 5 tamb\u00e9m \u00e9 poss\u00edvel, mas usa mais moedas.","title":"Prova DELTA de algoritmos"},{"location":"prova/#prova-delta-de-algoritmos","text":"Esta prova cont\u00e9m tr\u00eas quest\u00f5es e tem tempo total de dura\u00e7\u00e3o de 90 minutos . As regras da prova s\u00e3o simples: A prova \u00e9 individual. \u00c9 permitido consultar qualquer material na internet. N\u00e3o \u00e9 permitido consultar outras pessoas. N\u00e3o \u00e9 permitido copiar grandes trechos e/ou solu\u00e7\u00f5es prontas. Sempre que usar uma fonte externa, adicione uma refer\u00eancia no seu c\u00f3digo usando um coment\u00e1rio. Todas as quest\u00f5es de implementa\u00e7\u00e3o tem testes automatizados. A quantidade de testes que passam \u00e9 mostrada ao executar o testador. As quest\u00f5es avaliam a capacidade de desenhar uma solu\u00e7\u00e3o para os problemas apresentados e estrutur\u00e1-la usando uma linguagem de programa\u00e7\u00e3o. Todas as quest\u00f5es podem ser resolvidas usando conhecimentos b\u00e1sicos de Linguagem C . Em todas as quest\u00f5es voc\u00ea dever\u00e1 implementar somente a fun\u00e7\u00e3o pedida. Um arquivo .o com uma fun\u00e7\u00e3o main contendo testes automatizados \u00e9 fornecido para cada quest\u00e3o. Para testar basta executar o execut\u00e1vel criado. Importante Um aluno estar\u00e1 minimamente capacitado se acertar TODAS as quest\u00f5es no tempo da prova. Para fazer a prova voc\u00ea precisar\u00e1 dos pacotes build-essential libsystemd-dev instalados em seu sistema. Essa prova possui um sistema de telemetria que registra quando um aluno tenta fazer uma quest\u00e3o. Toda informa\u00e7\u00e3o \u00e9 coletada anonimamente e \u00e9 imposs\u00edvel associar uma tentativa de resolu\u00e7\u00e3o a um aluno em espec\u00edfico. Toda a informa\u00e7\u00e3o coletada ser\u00e1 usada para melhorar o curso de Engenharia da Computa\u00e7\u00e3o. Nenhuma informa\u00e7\u00e3o \u00e9 usada para nota .","title":"Prova DELTA de algoritmos"},{"location":"prova/#questao-1","text":"Seu trabalho ser\u00e1 criar uma fun\u00e7\u00e3o que identifica o tamanho da maior sequ\u00eancia estritamente crescente em um vetor. Uma sequ\u00eancia de n\u00fameros a_i, .... a_k a_i, .... a_k \u00e9 crescente se a_j < a_{j+1} a_j < a_{j+1} para todo j=i ... k-1 . Coloque sua resposta no arquivo questao1/solucao.c . Sua fun\u00e7\u00e3o dever\u00e1 ter assinatura int maior_sequencia_crescente(int *vetor, int n) . Para compilar seu programa use gcc -Wall -Og solucao.c testes.o -o testes-q1 -lsystemd","title":"Quest\u00e3o 1"},{"location":"prova/#exemplos","text":"O tamanho da maior sequ\u00eancia crescente de 3 2 1 3 5 7 9 8 \u00e9 5: ela come\u00e7a no 1 e vai at\u00e9 o 9 . O tamanho da maior sequ\u00eancia crescente de 5 6 4 7 3 8 \u00e9 2 e existe empate entre 5 6 , 4 7 e 3 8 .","title":"Exemplos"},{"location":"prova/#questao-2","text":"Balancear par\u00eanteses \u00e9 uma tarefa comum ao intepretar textos estruturados. Fa\u00e7a uma fun\u00e7\u00e3o int parenteses_balanceados(char *texto) que retorna 1 se os par\u00eanteses de um texto est\u00e3o balanceados e 0 caso contr\u00e1rio. Coloque sua resposta em questao2/solucao.c . Para compilar seu programa use gcc -Wall -Og solucao.c testes.o -o testes-q2 -lsystemd","title":"Quest\u00e3o 2"},{"location":"prova/#questao-3","text":"Voc\u00ea foi contratado para criar uma m\u00e1quina de caf\u00e9 que recebe pagamentos em dinheiro. Um dos pontos importantes \u00e9 devolver a quantidade correta de trocos usando moedas de 50, 25, 10, 5 e 1 centavos. Voc\u00ea dever\u00e1 fazer uma fun\u00e7\u00e3o void troco_moedas(int reais, int centavos, int *q50, int *q25, int *q10, int *q5, int *q1) que, dada a quantidade de reais e centavos a serem dados de troco retorne a quantidade de moedas de cada tipo a serem usadas. Voc\u00ea dever\u00e1 usar a menor quantidade de moedas poss\u00edvel. Voc\u00ea pode supor que tem infinitas moedas a sua disposi\u00e7\u00e3o. Coloque sua resposta em questao3/solucao.c . Para compilar seu programa use gcc -Wall -Og solucao.c testes.o -o testes-q3 -lsystemd","title":"Quest\u00e3o 3"},{"location":"prova/#exemplos_1","text":"Para devolver 35 centavos de troco retornamos uma moeda de 25 e uma moeda de 10. Note que retornar 3 moedas de 10 e uma de 5 tamb\u00e9m \u00e9 poss\u00edvel, mas usa mais moedas.","title":"Exemplos"}]}